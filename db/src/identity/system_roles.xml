<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <!-- ========== TABLE CREATION ========== -->

    <changeSet id="system_roles:table_creation" author="doc-assembly">
        <comment>Create system_roles table - platform-level administrative roles</comment>
        <createTable tableName="system_roles" schemaName="identity">
            <column name="id" type="uuid" defaultValueComputed="gen_random_uuid()">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="user_id" type="uuid">
                <constraints nullable="false"/>
            </column>
            <column name="role" type="system_role">
                <constraints nullable="false"/>
            </column>
            <column name="granted_by" type="uuid">
                <constraints nullable="true"/>
            </column>
            <column name="created_at" type="TIMESTAMPTZ" defaultValueComputed="CURRENT_TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

    <!-- ========== FOREIGN KEYS ========== -->

    <changeSet id="system_roles:add_fk_constraint:user_id" author="doc-assembly">
        <comment>FK to users</comment>
        <addForeignKeyConstraint
            baseTableSchemaName="identity"
            baseTableName="system_roles"
            baseColumnNames="user_id"
            constraintName="fk_system_roles_user_id"
            referencedTableSchemaName="identity"
            referencedTableName="users"
            referencedColumnNames="id"
            onDelete="CASCADE"/>
    </changeSet>

    <changeSet id="system_roles:add_fk_constraint:granted_by" author="doc-assembly">
        <comment>FK to users for granter tracking</comment>
        <addForeignKeyConstraint
            baseTableSchemaName="identity"
            baseTableName="system_roles"
            baseColumnNames="granted_by"
            constraintName="fk_system_roles_granted_by"
            referencedTableSchemaName="identity"
            referencedTableName="users"
            referencedColumnNames="id"
            onDelete="SET NULL"/>
    </changeSet>

    <!-- ========== UNIQUE CONSTRAINTS ========== -->

    <changeSet id="system_roles:add_unique_constraint:user_id" author="doc-assembly">
        <comment>One system role per user</comment>
        <addUniqueConstraint
            schemaName="identity"
            tableName="system_roles"
            columnNames="user_id"
            constraintName="uq_system_roles_user_id"/>
    </changeSet>

    <!-- ========== INDEXES ========== -->

    <changeSet id="system_roles:index_creation:user_id" author="doc-assembly">
        <comment>Index for user-based lookups</comment>
        <createIndex indexName="idx_system_roles_user_id" tableName="system_roles" schemaName="identity">
            <column name="user_id"/>
        </createIndex>
    </changeSet>

    <changeSet id="system_roles:index_creation:role" author="doc-assembly">
        <comment>Index for role filtering</comment>
        <createIndex indexName="idx_system_roles_role" tableName="system_roles" schemaName="identity">
            <column name="role"/>
        </createIndex>
    </changeSet>

    <!-- ========== SYNC WITH SYSTEM TENANT/WORKSPACE MEMBERSHIPS ========== -->

    <changeSet id="system_roles:function:sync_memberships" author="doc-assembly">
        <comment>Function to sync system roles with tenant_members and workspace_members for system tenant/workspace</comment>
        <sql splitStatements="false">
            CREATE OR REPLACE FUNCTION identity.sync_system_role_memberships()
            RETURNS TRIGGER AS $$
            DECLARE
                v_system_tenant_id UUID;
                v_system_workspace_id UUID;
                v_tenant_role tenant_role;
                v_workspace_role workspace_role;
            BEGIN
                -- Get system tenant and workspace
                SELECT id INTO v_system_tenant_id FROM tenancy.tenants WHERE is_system = TRUE;
                SELECT id INTO v_system_workspace_id FROM tenancy.workspaces WHERE tenant_id = v_system_tenant_id AND type = 'SYSTEM';

                IF v_system_tenant_id IS NULL OR v_system_workspace_id IS NULL THEN
                    RETURN COALESCE(NEW, OLD);
                END IF;

                -- Handle DELETE
                IF TG_OP = 'DELETE' THEN
                    DELETE FROM identity.tenant_members
                    WHERE user_id = OLD.user_id AND tenant_id = v_system_tenant_id;

                    DELETE FROM identity.workspace_members
                    WHERE user_id = OLD.user_id AND workspace_id = v_system_workspace_id;

                    RETURN OLD;
                END IF;

                -- Map system role to tenant/workspace roles
                IF NEW.role = 'SUPERADMIN' THEN
                    v_tenant_role := 'TENANT_OWNER';
                    v_workspace_role := 'OWNER';
                ELSIF NEW.role = 'PLATFORM_ADMIN' THEN
                    v_tenant_role := 'TENANT_ADMIN';
                    v_workspace_role := 'ADMIN';
                END IF;

                -- Handle INSERT
                IF TG_OP = 'INSERT' THEN
                    INSERT INTO identity.tenant_members (tenant_id, user_id, role, membership_status, granted_by)
                    VALUES (v_system_tenant_id, NEW.user_id, v_tenant_role, 'ACTIVE', NEW.granted_by)
                    ON CONFLICT (tenant_id, user_id) DO UPDATE SET role = EXCLUDED.role;

                    INSERT INTO identity.workspace_members (workspace_id, user_id, role, membership_status, invited_by, joined_at)
                    VALUES (v_system_workspace_id, NEW.user_id, v_workspace_role, 'ACTIVE', NEW.granted_by, CURRENT_TIMESTAMP)
                    ON CONFLICT (workspace_id, user_id) DO UPDATE SET role = EXCLUDED.role;

                    RETURN NEW;
                END IF;

                -- Handle UPDATE (use UPSERT in case membership doesn't exist)
                IF TG_OP = 'UPDATE' THEN
                    INSERT INTO identity.tenant_members (tenant_id, user_id, role, membership_status, granted_by)
                    VALUES (v_system_tenant_id, NEW.user_id, v_tenant_role, 'ACTIVE', NEW.granted_by)
                    ON CONFLICT (tenant_id, user_id) DO UPDATE SET role = EXCLUDED.role;

                    INSERT INTO identity.workspace_members (workspace_id, user_id, role, membership_status, invited_by, joined_at)
                    VALUES (v_system_workspace_id, NEW.user_id, v_workspace_role, 'ACTIVE', NEW.granted_by, CURRENT_TIMESTAMP)
                    ON CONFLICT (workspace_id, user_id) DO UPDATE SET role = EXCLUDED.role;

                    RETURN NEW;
                END IF;

                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        </sql>
        <rollback>DROP FUNCTION IF EXISTS identity.sync_system_role_memberships();</rollback>
    </changeSet>

    <changeSet id="system_roles:trigger:sync_memberships" author="doc-assembly">
        <comment>Trigger to sync system roles with memberships on INSERT/UPDATE/DELETE</comment>
        <sql>
            DROP TRIGGER IF EXISTS trigger_sync_system_role_memberships ON identity.system_roles;
            CREATE TRIGGER trigger_sync_system_role_memberships
            AFTER INSERT OR UPDATE OR DELETE ON identity.system_roles
            FOR EACH ROW EXECUTE FUNCTION identity.sync_system_role_memberships();
        </sql>
        <rollback>DROP TRIGGER IF EXISTS trigger_sync_system_role_memberships ON identity.system_roles;</rollback>
    </changeSet>

</databaseChangeLog>
